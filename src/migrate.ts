import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { db } from '@/model/client.ts';
import { userSeeder } from '@/model/seeders/user.seed.ts';
import { FileMigrationProvider, Migrator, NO_MIGRATIONS } from 'npm:kysely';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const migrationFolder = path.resolve(__dirname, './model/migrations');
const targetSqlFolder = path.resolve(__dirname, './model/generated');

const migrator = new Migrator({
  db,
  provider: new FileMigrationProvider({ fs, path, migrationFolder }),
  migrationTableName: '_migration',
  migrationLockTableName: '_migration_lock',
  allowUnorderedMigrations: false,
});

async function runMigration() {
  const { error, results } = await migrator.migrateToLatest();

  if (error) {
    console.error('ğŸ”¥ Failed to migrate', error);
    Deno.exit(1);
  }

  results?.map((it) => {
    if (it.status === 'Success') {
      console.info(
        `âŒ›ï¸ Migration "${it.migrationName}" was executed successfully`,
      );
    } else if (it.status === 'Error') {
      console.error(`ğŸ”¥ Failed to execute migration "${it.migrationName}"`);
    }
  });

  await db.destroy();
}

async function rollbackMigration() {
  const { error, results } = await migrator.migrateTo(NO_MIGRATIONS);

  if (error) {
    console.error('ğŸ”¥ Failed to rollback', error);
    Deno.exit(1);
  }

  return results?.map((it) => {
    if (it.status === 'Success') {
      console.info(`âŒ›ï¸ Rolling back to "${it.migrationName}"`);
    } else if (it.status === 'Error') {
      console.error(`ğŸ”¥ Failed to rollback migration "${it.migrationName}"`);
    }
  });
}

async function runSeeder() {
  await userSeeder(db)
    .then(() => {
      console.info('ğŸ€ Database has been populated with seeders');
      Deno.exit(0);
    })
    .catch((e) => {
      console.error('ğŸ”¥ Failed running database seeder:', e.message);
      Deno.exit(1);
    })
    .finally(async () => await db.destroy());
}

async function generateSQL() {
  // Create directory if it doesn't exist (group by UTC date)
  const currentDate = new Date().toISOString().split('T')[0];
  const targetDir = path.resolve(`${targetSqlFolder}/${currentDate}`);
  await fs.mkdir(targetDir, { recursive: true });

  const migrations = await migrator.getMigrations();
  migrations.map(async (item) => {
    // Write file with migration name
    console.info(`ğŸ“ Writing migration "${item.name}"`);
    const filePath = path.resolve(`${targetDir}/${item.name}.sql`);
    const contentHeaderLine1 = `-- This file was generated by Kysely at ${
      new Date().toISOString()
    }`;
    const contentHeaderLine2 = `-- Migration name: ${item.name}`;
    const contentHeaderLine3 = `-- Executed at: ${item.executedAt}`;
    const contentHeader = `${contentHeaderLine1}\n${contentHeaderLine2}\n${contentHeaderLine3}\n`;
    await fs.writeFile(filePath, contentHeader, { encoding: 'utf8' });
  });
}

type Commands = 'rollback' | 'seed' | 'generate-sql';

switch (Deno.args[0] as Commands) {
  case 'rollback':
    console.info('ğŸ€ Rolling back migration...');
    rollbackMigration();
    break;
  case 'seed':
    console.info('ğŸ€ Populating database with seeders...');
    runSeeder();
    break;
  case 'generate-sql':
    console.info('ğŸ€ Creating SQL migrations queries...');
    generateSQL();
    break;
  default:
    console.info('ğŸ€ Running database migration...');
    runMigration();
    break;
}
