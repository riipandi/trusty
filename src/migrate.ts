import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { consola } from "consola";

import { db } from "@/model/client";
import { userSeeder } from "@/model/seeders/user.seed";
import { FileMigrationProvider, Migrator, NO_MIGRATIONS } from "kysely";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const migrationFolder = path.resolve(__dirname, "./model/migrations");
const targetSqlFolder = path.resolve(__dirname, "./model/generated");

const migrator = new Migrator({
  db,
  provider: new FileMigrationProvider({ fs, path, migrationFolder }),
  migrationTableName: "_migration",
  migrationLockTableName: "_migration_lock",
  allowUnorderedMigrations: false,
});

async function runMigration() {
  const { error, results } = await migrator.migrateToLatest();

  if (error) {
    consola.error("ğŸ”¥ Failed to migrate", error);
    process.exit(1);
  }

  results?.map((it) => {
    if (it.status === "Success") {
      consola.info(`âŒ›ï¸ Migration "${it.migrationName}" was executed successfully`);
    } else if (it.status === "Error") {
      consola.error(`ğŸ”¥ Failed to execute migration "${it.migrationName}"`);
    }
  });

  await db.destroy();
}

async function rollbackMigration() {
  const { error, results } = await migrator.migrateTo(NO_MIGRATIONS);

  if (error) {
    consola.error("ğŸ”¥ Failed to rollback", error);
    process.exit(1);
  }

  return results?.map((it) => {
    if (it.status === "Success") {
      consola.info(`âŒ›ï¸ Rolling back to "${it.migrationName}"`);
    } else if (it.status === "Error") {
      consola.error(`ğŸ”¥ Failed to rollback migration "${it.migrationName}"`);
    }
  });
}

async function runSeeder() {
  await userSeeder(db)
    .then(async () => {
      consola.info("ğŸ€ Database has been populated with seeders");
      process.exit(0);
    })
    .catch(async (e) => {
      consola.error("ğŸ”¥ Failed running database seeder:", e.message);
      process.exit(1);
    })
    .finally(async () => await db.destroy());
}

async function generateSQL() {
  // Create directory if it doesn't exist (group by UTC date)
  const currentDate = new Date().toISOString().split("T")[0];
  const targetDir = path.resolve(`${targetSqlFolder}/${currentDate}`);
  await fs.mkdir(targetDir, { recursive: true });

  const migrations = await migrator.getMigrations();
  migrations.map(async (item) => {
    // Write file with migration name
    consola.info(`ğŸ“ Writing migration "${item.name}"`);
    const filePath = path.resolve(`${targetDir}/${item.name}.sql`);
    const contentHeaderLine1 = `-- This file was generated by Kysely at ${new Date().toISOString()}`;
    const contentHeaderLine2 = `-- Migration name: ${item.name}`;
    const contentHeaderLine3 = `-- Executed at: ${item.executedAt}`;
    const contentHeader = `${contentHeaderLine1}\n${contentHeaderLine2}\n${contentHeaderLine3}\n`;
    await fs.writeFile(filePath, contentHeader, { encoding: "utf8" });
  });
}

type Commands = "rollback" | "seed" | "generate-sql";

switch (process.argv[2] as Commands) {
  case "rollback":
    consola.info("ğŸ€ Rolling back migration...");
    rollbackMigration();
    break;
  case "seed":
    consola.info("ğŸ€ Populating database with seeders...");
    runSeeder();
    break;
  case "generate-sql":
    consola.info("ğŸ€ Creating SQL migrations queries...");
    generateSQL();
    break;
  default:
    consola.info("ğŸ€ Running database migration...");
    runMigration();
    break;
}
